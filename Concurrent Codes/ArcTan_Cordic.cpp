#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <math.h>
#include <mutex>

using namespace std;
using namespace std::chrono;

std::mutex m;

auto objects1 = std::make_unique<int[]>(14);
auto d = std::make_unique<int[] >(14);
auto objects2 = std::make_unique<double[]>(61);
auto k = std::make_unique<double[] >(61);
auto objects3 = std::make_unique<double[]>(61);
auto ph = std::make_unique<double[] >(61);

const double PI = 3.141592653589793238463;

double arctan1(double real_x, double imag_x)
{
	using namespace std;
	std::mutex m;
	auto objects1 = std::make_unique<double[]>(61);
	auto k = std::make_unique<double[] >(61);
	auto objects2 = std::make_unique<double[]>(61);
	auto ph = std::make_unique<double[] >(61);

	double angle_cal = 0;
	double k[61] = { 1, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.00195312, 0.000976562, 0.000488281, 0.000244141, 0.00012207, 6.10352e-05, 3.05176e-05, 1.52588e-05, 7.62939e-06, 3.8147e-06, 1.90735e-06, 9.53674e-07, 4.76837e-07, 2.38419e-07, 1.19209e-07, 5.96046e-08, 2.98023e-08, 1.49012e-08, 7.45058e-09, 3.72529e-09, 1.86265e-09, 9.31323e-10, 4.65661e-10, 2.32831e-10, 1.16415e-10, 5.82077e-11, 2.91038e-11, 1.45519e-11, 7.27596e-12, 3.63798e-12, 1.81899e-12, 9.09495e-13, 4.54747e-13, 2.27374e-13, 1.13687e-13, 5.68434e-14, 2.84217e-14, 1.42109e-14, 7.10543e-15, 3.55271e-15, 1.77636e-15, 8.88178e-16, 4.44089e-16, 2.22045e-16, 1.11022e-16, 5.55112e-17, 2.77556e-17, 1.38778e-17, 6.93889e-18, 3.46945e-18, 1.73472e-18, 8.67362e-19 };   //typical cordic values
	double ph[61] = { 7.8539816339744830962e-01, 4.6364760900080611621e-01, 2.4497866312686415417e-01, 1.2435499454676143503e-01, 6.2418809995957348474e-02, 3.1239833430268276254e-02, 1.5623728620476830803e-02, 7.8123410601011112965e-03, 3.9062301319669718276e-03, 1.9531225164788186851e-03, 9.7656218955931943040e-04, 4.8828121119489827547e-04, 2.4414062014936176402e-04, 1.2207031189367020424e-04, 6.1035156174208775022e-05, 3.0517578115526096862e-05, 1.5258789061315762107e-05, 7.6293945311019702634e-06, 3.8146972656064962829e-06, 1.9073486328101870354e-06, 9.5367431640596087942e-07, 4.7683715820308885993e-07, 2.3841857910155798249e-07, 1.1920928955078068531e-07, 5.9604644775390554414e-08, 2.9802322387695303677e-08, 1.4901161193847655147e-08, 7.4505805969238279871e-09, 3.7252902984619140453e-09, 1.8626451492309570291e-09, 9.3132257461547851536e-10, 4.6566128730773925778e-10, 2.3283064365386962890e-10, 1.1641532182693481445e-10, 5.8207660913467407226e-11, 2.9103830456733703613e-11, 1.4551915228366851807e-11, 7.2759576141834259033e-12, 3.6379788070917129517e-12, 1.8189894035458564758e-12, 9.0949470177292823792e-13, 4.5474735088646411896e-13, 2.2737367544323205948e-13, 1.1368683772161602974e-13, 5.6843418860808014870e-14, 2.8421709430404007435e-14, 1.4210854715202003717e-14, 7.1054273576010018587e-15, 3.5527136788005009294e-15, 1.7763568394002504647e-15, 8.8817841970012523234e-16, 4.4408920985006261617e-16, 2.2204460492503130808e-16, 1.1102230246251565404e-16, 5.5511151231257827021e-17, 2.7755575615628913511e-17, 1.3877787807814456755e-17, 6.9388939039072283776e-18, 3.4694469519536141888e-18, 1.7347234759768070944e-18, 8.673617379884035472e-19 };

	double ph_temp = 0;
	double y_re = 0;
	double y_im = 0;
	double tol = 1;
	int sign = 0;

	if (real_x < 0. && imag_x > 0.)
	{
		real_x = -real_x;
		sign = 1;
	}

	else if (real_x < 0. && imag_x < 0.)
	{
		real_x = -real_x;
		imag_x = -imag_x;
	}

	else if (real_x > 0.)
	{
		real_x = real_x;
		imag_x = imag_x;
	}

	if (imag_x > 0.)
	{
		ph_temp = -PI / 2;
		y_re = imag_x;
		y_im = -real_x;

	}
	else if (imag_x < 0.)
	{
		ph_temp = PI / 2;
		y_re = -imag_x;
		y_im = real_x;
	}

	for (int i = 0; i < 32; i++)
	{

		if (y_im > 0.)
		{
			y_re = y_re + y_im * k[i];
			double y_re1 = y_re - y_im * k[i];
			y_im = y_im - y_re1 * k[i];
			ph_temp = ph_temp - ph[i];
		}
		else if (y_im < 0.)
		{
			y_re = y_re - y_im * k[i];
			double y_re1 = y_re + y_im * k[i];
			y_im = y_im + y_re1 * k[i];
			ph_temp = ph_temp + ph[i];
		}

		angle_cal = -ph_temp;
	}

	if (sign == 1)
	{
		angle_cal = -angle_cal;
	}

	else
	{
		angle_cal = angle_cal;
	}

	return 180 * angle_cal / PI;

}

double arctan2(double real_x, double imag_x)
{
	using namespace std;
	std::mutex m;
	auto objects1 = std::make_unique<double[]>(61);
	auto k = std::make_unique<double[] >(61);
	auto objects2 = std::make_unique<double[]>(61);
	auto ph = std::make_unique<double[] >(61);

	double angle_cal = 0;
	double k[61] = { 1, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.00195312, 0.000976562, 0.000488281, 0.000244141, 0.00012207, 6.10352e-05, 3.05176e-05, 1.52588e-05, 7.62939e-06, 3.8147e-06, 1.90735e-06, 9.53674e-07, 4.76837e-07, 2.38419e-07, 1.19209e-07, 5.96046e-08, 2.98023e-08, 1.49012e-08, 7.45058e-09, 3.72529e-09, 1.86265e-09, 9.31323e-10, 4.65661e-10, 2.32831e-10, 1.16415e-10, 5.82077e-11, 2.91038e-11, 1.45519e-11, 7.27596e-12, 3.63798e-12, 1.81899e-12, 9.09495e-13, 4.54747e-13, 2.27374e-13, 1.13687e-13, 5.68434e-14, 2.84217e-14, 1.42109e-14, 7.10543e-15, 3.55271e-15, 1.77636e-15, 8.88178e-16, 4.44089e-16, 2.22045e-16, 1.11022e-16, 5.55112e-17, 2.77556e-17, 1.38778e-17, 6.93889e-18, 3.46945e-18, 1.73472e-18, 8.67362e-19 };   //typical cordic values
	double ph[61] = { 7.8539816339744830962e-01, 4.6364760900080611621e-01, 2.4497866312686415417e-01, 1.2435499454676143503e-01, 6.2418809995957348474e-02, 3.1239833430268276254e-02, 1.5623728620476830803e-02, 7.8123410601011112965e-03, 3.9062301319669718276e-03, 1.9531225164788186851e-03, 9.7656218955931943040e-04, 4.8828121119489827547e-04, 2.4414062014936176402e-04, 1.2207031189367020424e-04, 6.1035156174208775022e-05, 3.0517578115526096862e-05, 1.5258789061315762107e-05, 7.6293945311019702634e-06, 3.8146972656064962829e-06, 1.9073486328101870354e-06, 9.5367431640596087942e-07, 4.7683715820308885993e-07, 2.3841857910155798249e-07, 1.1920928955078068531e-07, 5.9604644775390554414e-08, 2.9802322387695303677e-08, 1.4901161193847655147e-08, 7.4505805969238279871e-09, 3.7252902984619140453e-09, 1.8626451492309570291e-09, 9.3132257461547851536e-10, 4.6566128730773925778e-10, 2.3283064365386962890e-10, 1.1641532182693481445e-10, 5.8207660913467407226e-11, 2.9103830456733703613e-11, 1.4551915228366851807e-11, 7.2759576141834259033e-12, 3.6379788070917129517e-12, 1.8189894035458564758e-12, 9.0949470177292823792e-13, 4.5474735088646411896e-13, 2.2737367544323205948e-13, 1.1368683772161602974e-13, 5.6843418860808014870e-14, 2.8421709430404007435e-14, 1.4210854715202003717e-14, 7.1054273576010018587e-15, 3.5527136788005009294e-15, 1.7763568394002504647e-15, 8.8817841970012523234e-16, 4.4408920985006261617e-16, 2.2204460492503130808e-16, 1.1102230246251565404e-16, 5.5511151231257827021e-17, 2.7755575615628913511e-17, 1.3877787807814456755e-17, 6.9388939039072283776e-18, 3.4694469519536141888e-18, 1.7347234759768070944e-18, 8.673617379884035472e-19 };

	double ph_temp = 0;
	double y_re = 0;
	double y_im = 0;
	double tol = 1;
	int sign = 0;

	if (real_x < 0. && imag_x > 0.)
	{
		real_x = -real_x;
		sign = 1;
	}

	else if (real_x < 0. && imag_x < 0.)
	{
		real_x = -real_x;
		imag_x = -imag_x;
	}

	else if (real_x > 0.)
	{
		real_x = real_x;
		imag_x = imag_x;
	}

	if (imag_x > 0.)
	{
		ph_temp = -PI / 2;
		y_re = imag_x;
		y_im = -real_x;

	}
	else if (imag_x < 0.)
	{
		ph_temp = PI / 2;
		y_re = -imag_x;
		y_im = real_x;
	}

	for (int i = 0; i < 32; i++)
	{

		if (y_im > 0.)
		{
			y_re = y_re + y_im * k[i];
			double y_re1 = y_re - y_im * k[i];
			y_im = y_im - y_re1 * k[i];
			ph_temp = ph_temp - ph[i];
		}
		else if (y_im < 0.)
		{
			y_re = y_re - y_im * k[i];
			double y_re1 = y_re + y_im * k[i];
			y_im = y_im + y_re1 * k[i];
			ph_temp = ph_temp + ph[i];
		}

		angle_cal = -ph_temp;
	}

	if (sign == 1)
	{
		angle_cal = -angle_cal;
	}

	else
	{
		angle_cal = angle_cal;
	}

	return 180 * angle_cal / PI;

}

double arctan3(double real_x, double imag_x)
{
	using namespace std;
	std::mutex m;
	auto objects1 = std::make_unique<double[]>(61);
	auto k = std::make_unique<double[] >(61);
	auto objects2 = std::make_unique<double[]>(61);
	auto ph = std::make_unique<double[] >(61);

	double angle_cal = 0;
	double k[61] = { 1, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.00195312, 0.000976562, 0.000488281, 0.000244141, 0.00012207, 6.10352e-05, 3.05176e-05, 1.52588e-05, 7.62939e-06, 3.8147e-06, 1.90735e-06, 9.53674e-07, 4.76837e-07, 2.38419e-07, 1.19209e-07, 5.96046e-08, 2.98023e-08, 1.49012e-08, 7.45058e-09, 3.72529e-09, 1.86265e-09, 9.31323e-10, 4.65661e-10, 2.32831e-10, 1.16415e-10, 5.82077e-11, 2.91038e-11, 1.45519e-11, 7.27596e-12, 3.63798e-12, 1.81899e-12, 9.09495e-13, 4.54747e-13, 2.27374e-13, 1.13687e-13, 5.68434e-14, 2.84217e-14, 1.42109e-14, 7.10543e-15, 3.55271e-15, 1.77636e-15, 8.88178e-16, 4.44089e-16, 2.22045e-16, 1.11022e-16, 5.55112e-17, 2.77556e-17, 1.38778e-17, 6.93889e-18, 3.46945e-18, 1.73472e-18, 8.67362e-19 };   //typical cordic values
	double ph[61] = { 7.8539816339744830962e-01, 4.6364760900080611621e-01, 2.4497866312686415417e-01, 1.2435499454676143503e-01, 6.2418809995957348474e-02, 3.1239833430268276254e-02, 1.5623728620476830803e-02, 7.8123410601011112965e-03, 3.9062301319669718276e-03, 1.9531225164788186851e-03, 9.7656218955931943040e-04, 4.8828121119489827547e-04, 2.4414062014936176402e-04, 1.2207031189367020424e-04, 6.1035156174208775022e-05, 3.0517578115526096862e-05, 1.5258789061315762107e-05, 7.6293945311019702634e-06, 3.8146972656064962829e-06, 1.9073486328101870354e-06, 9.5367431640596087942e-07, 4.7683715820308885993e-07, 2.3841857910155798249e-07, 1.1920928955078068531e-07, 5.9604644775390554414e-08, 2.9802322387695303677e-08, 1.4901161193847655147e-08, 7.4505805969238279871e-09, 3.7252902984619140453e-09, 1.8626451492309570291e-09, 9.3132257461547851536e-10, 4.6566128730773925778e-10, 2.3283064365386962890e-10, 1.1641532182693481445e-10, 5.8207660913467407226e-11, 2.9103830456733703613e-11, 1.4551915228366851807e-11, 7.2759576141834259033e-12, 3.6379788070917129517e-12, 1.8189894035458564758e-12, 9.0949470177292823792e-13, 4.5474735088646411896e-13, 2.2737367544323205948e-13, 1.1368683772161602974e-13, 5.6843418860808014870e-14, 2.8421709430404007435e-14, 1.4210854715202003717e-14, 7.1054273576010018587e-15, 3.5527136788005009294e-15, 1.7763568394002504647e-15, 8.8817841970012523234e-16, 4.4408920985006261617e-16, 2.2204460492503130808e-16, 1.1102230246251565404e-16, 5.5511151231257827021e-17, 2.7755575615628913511e-17, 1.3877787807814456755e-17, 6.9388939039072283776e-18, 3.4694469519536141888e-18, 1.7347234759768070944e-18, 8.673617379884035472e-19 };

	double ph_temp = 0;
	double y_re = 0;
	double y_im = 0;
	double tol = 1;
	int sign = 0;

	if (real_x < 0. && imag_x > 0.)
	{
		real_x = -real_x;
		sign = 1;
	}

	else if (real_x < 0. && imag_x < 0.)
	{
		real_x = -real_x;
		imag_x = -imag_x;
	}

	else if (real_x > 0.)
	{
		real_x = real_x;
		imag_x = imag_x;
	}

	if (imag_x > 0.)
	{
		ph_temp = -PI / 2;
		y_re = imag_x;
		y_im = -real_x;

	}
	else if (imag_x < 0.)
	{
		ph_temp = PI / 2;
		y_re = -imag_x;
		y_im = real_x;
	}

	for (int i = 0; i < 32; i++)
	{

		if (y_im > 0.)
		{
			y_re = y_re + y_im * k[i];
			double y_re1 = y_re - y_im * k[i];
			y_im = y_im - y_re1 * k[i];
			ph_temp = ph_temp - ph[i];
		}
		else if (y_im < 0.)
		{
			y_re = y_re - y_im * k[i];
			double y_re1 = y_re + y_im * k[i];
			y_im = y_im + y_re1 * k[i];
			ph_temp = ph_temp + ph[i];
		}

		angle_cal = -ph_temp;
	}

	if (sign == 1)
	{
		angle_cal = -angle_cal;
	}

	else
	{
		angle_cal = angle_cal;
	}

	return 180 * angle_cal / PI;

}

double arctan4(double real_x, double imag_x)
{
	using namespace std;
	std::mutex m;
	auto objects1 = std::make_unique<double[]>(61);
	auto k = std::make_unique<double[] >(61);
	auto objects2 = std::make_unique<double[]>(61);
	auto ph = std::make_unique<double[] >(61);

	double angle_cal = 0;
	double k[61] = { 1, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.00195312, 0.000976562, 0.000488281, 0.000244141, 0.00012207, 6.10352e-05, 3.05176e-05, 1.52588e-05, 7.62939e-06, 3.8147e-06, 1.90735e-06, 9.53674e-07, 4.76837e-07, 2.38419e-07, 1.19209e-07, 5.96046e-08, 2.98023e-08, 1.49012e-08, 7.45058e-09, 3.72529e-09, 1.86265e-09, 9.31323e-10, 4.65661e-10, 2.32831e-10, 1.16415e-10, 5.82077e-11, 2.91038e-11, 1.45519e-11, 7.27596e-12, 3.63798e-12, 1.81899e-12, 9.09495e-13, 4.54747e-13, 2.27374e-13, 1.13687e-13, 5.68434e-14, 2.84217e-14, 1.42109e-14, 7.10543e-15, 3.55271e-15, 1.77636e-15, 8.88178e-16, 4.44089e-16, 2.22045e-16, 1.11022e-16, 5.55112e-17, 2.77556e-17, 1.38778e-17, 6.93889e-18, 3.46945e-18, 1.73472e-18, 8.67362e-19 };   //typical cordic values
	double ph[61] = { 7.8539816339744830962e-01, 4.6364760900080611621e-01, 2.4497866312686415417e-01, 1.2435499454676143503e-01, 6.2418809995957348474e-02, 3.1239833430268276254e-02, 1.5623728620476830803e-02, 7.8123410601011112965e-03, 3.9062301319669718276e-03, 1.9531225164788186851e-03, 9.7656218955931943040e-04, 4.8828121119489827547e-04, 2.4414062014936176402e-04, 1.2207031189367020424e-04, 6.1035156174208775022e-05, 3.0517578115526096862e-05, 1.5258789061315762107e-05, 7.6293945311019702634e-06, 3.8146972656064962829e-06, 1.9073486328101870354e-06, 9.5367431640596087942e-07, 4.7683715820308885993e-07, 2.3841857910155798249e-07, 1.1920928955078068531e-07, 5.9604644775390554414e-08, 2.9802322387695303677e-08, 1.4901161193847655147e-08, 7.4505805969238279871e-09, 3.7252902984619140453e-09, 1.8626451492309570291e-09, 9.3132257461547851536e-10, 4.6566128730773925778e-10, 2.3283064365386962890e-10, 1.1641532182693481445e-10, 5.8207660913467407226e-11, 2.9103830456733703613e-11, 1.4551915228366851807e-11, 7.2759576141834259033e-12, 3.6379788070917129517e-12, 1.8189894035458564758e-12, 9.0949470177292823792e-13, 4.5474735088646411896e-13, 2.2737367544323205948e-13, 1.1368683772161602974e-13, 5.6843418860808014870e-14, 2.8421709430404007435e-14, 1.4210854715202003717e-14, 7.1054273576010018587e-15, 3.5527136788005009294e-15, 1.7763568394002504647e-15, 8.8817841970012523234e-16, 4.4408920985006261617e-16, 2.2204460492503130808e-16, 1.1102230246251565404e-16, 5.5511151231257827021e-17, 2.7755575615628913511e-17, 1.3877787807814456755e-17, 6.9388939039072283776e-18, 3.4694469519536141888e-18, 1.7347234759768070944e-18, 8.673617379884035472e-19 };

	double ph_temp = 0;
	double y_re = 0;
	double y_im = 0;
	double tol = 1;
	int sign = 0;

	if (real_x < 0. && imag_x > 0.)
	{
		real_x = -real_x;
		sign = 1;
	}

	else if (real_x < 0. && imag_x < 0.)
	{
		real_x = -real_x;
		imag_x = -imag_x;
	}

	else if (real_x > 0.)
	{
		real_x = real_x;
		imag_x = imag_x;
	}

	if (imag_x > 0.)
	{
		ph_temp = -PI / 2;
		y_re = imag_x;
		y_im = -real_x;

	}
	else if (imag_x < 0.)
	{
		ph_temp = PI / 2;
		y_re = -imag_x;
		y_im = real_x;
	}

	for (int i = 0; i < 32; i++)
	{

		if (y_im > 0.)
		{
			y_re = y_re + y_im * k[i];
			double y_re1 = y_re - y_im * k[i];
			y_im = y_im - y_re1 * k[i];
			ph_temp = ph_temp - ph[i];
		}
		else if (y_im < 0.)
		{
			y_re = y_re - y_im * k[i];
			double y_re1 = y_re + y_im * k[i];
			y_im = y_im + y_re1 * k[i];
			ph_temp = ph_temp + ph[i];
		}

		angle_cal = -ph_temp;
	}

	if (sign == 1)
	{
		angle_cal = -angle_cal;
	}

	else
	{
		angle_cal = angle_cal;
	}

	return 180 * angle_cal / PI;

}

double arctan5(double real_x, double imag_x)
{
	using namespace std;
	std::mutex m;
	auto objects1 = std::make_unique<double[]>(61);
	auto k = std::make_unique<double[] >(61);
	auto objects2 = std::make_unique<double[]>(61);
	auto ph = std::make_unique<double[] >(61);

	double angle_cal = 0;
	double k[61] = { 1, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625, 0.00195312, 0.000976562, 0.000488281, 0.000244141, 0.00012207, 6.10352e-05, 3.05176e-05, 1.52588e-05, 7.62939e-06, 3.8147e-06, 1.90735e-06, 9.53674e-07, 4.76837e-07, 2.38419e-07, 1.19209e-07, 5.96046e-08, 2.98023e-08, 1.49012e-08, 7.45058e-09, 3.72529e-09, 1.86265e-09, 9.31323e-10, 4.65661e-10, 2.32831e-10, 1.16415e-10, 5.82077e-11, 2.91038e-11, 1.45519e-11, 7.27596e-12, 3.63798e-12, 1.81899e-12, 9.09495e-13, 4.54747e-13, 2.27374e-13, 1.13687e-13, 5.68434e-14, 2.84217e-14, 1.42109e-14, 7.10543e-15, 3.55271e-15, 1.77636e-15, 8.88178e-16, 4.44089e-16, 2.22045e-16, 1.11022e-16, 5.55112e-17, 2.77556e-17, 1.38778e-17, 6.93889e-18, 3.46945e-18, 1.73472e-18, 8.67362e-19 };   //typical cordic values
	double ph[61] = { 7.8539816339744830962e-01, 4.6364760900080611621e-01, 2.4497866312686415417e-01, 1.2435499454676143503e-01, 6.2418809995957348474e-02, 3.1239833430268276254e-02, 1.5623728620476830803e-02, 7.8123410601011112965e-03, 3.9062301319669718276e-03, 1.9531225164788186851e-03, 9.7656218955931943040e-04, 4.8828121119489827547e-04, 2.4414062014936176402e-04, 1.2207031189367020424e-04, 6.1035156174208775022e-05, 3.0517578115526096862e-05, 1.5258789061315762107e-05, 7.6293945311019702634e-06, 3.8146972656064962829e-06, 1.9073486328101870354e-06, 9.5367431640596087942e-07, 4.7683715820308885993e-07, 2.3841857910155798249e-07, 1.1920928955078068531e-07, 5.9604644775390554414e-08, 2.9802322387695303677e-08, 1.4901161193847655147e-08, 7.4505805969238279871e-09, 3.7252902984619140453e-09, 1.8626451492309570291e-09, 9.3132257461547851536e-10, 4.6566128730773925778e-10, 2.3283064365386962890e-10, 1.1641532182693481445e-10, 5.8207660913467407226e-11, 2.9103830456733703613e-11, 1.4551915228366851807e-11, 7.2759576141834259033e-12, 3.6379788070917129517e-12, 1.8189894035458564758e-12, 9.0949470177292823792e-13, 4.5474735088646411896e-13, 2.2737367544323205948e-13, 1.1368683772161602974e-13, 5.6843418860808014870e-14, 2.8421709430404007435e-14, 1.4210854715202003717e-14, 7.1054273576010018587e-15, 3.5527136788005009294e-15, 1.7763568394002504647e-15, 8.8817841970012523234e-16, 4.4408920985006261617e-16, 2.2204460492503130808e-16, 1.1102230246251565404e-16, 5.5511151231257827021e-17, 2.7755575615628913511e-17, 1.3877787807814456755e-17, 6.9388939039072283776e-18, 3.4694469519536141888e-18, 1.7347234759768070944e-18, 8.673617379884035472e-19 };

	double ph_temp = 0;
	double y_re = 0;
	double y_im = 0;
	double tol = 1;
	int sign = 0;

	if (real_x < 0. && imag_x > 0.)
	{
		real_x = -real_x;
		sign = 1;
	}

	else if (real_x < 0. && imag_x < 0.)
	{
		real_x = -real_x;
		imag_x = -imag_x;
	}

	else if (real_x > 0.)
	{
		real_x = real_x;
		imag_x = imag_x;
	}

	if (imag_x > 0.)
	{
		ph_temp = -PI / 2;
		y_re = imag_x;
		y_im = -real_x;

	}
	else if (imag_x < 0.)
	{
		ph_temp = PI / 2;
		y_re = -imag_x;
		y_im = real_x;
	}

	for (int i = 0; i < 32; i++)
	{

		if (y_im > 0.)
		{
			y_re = y_re + y_im * k[i];
			double y_re1 = y_re - y_im * k[i];
			y_im = y_im - y_re1 * k[i];
			ph_temp = ph_temp - ph[i];
		}
		else if (y_im < 0.)
		{
			y_re = y_re - y_im * k[i];
			double y_re1 = y_re + y_im * k[i];
			y_im = y_im + y_re1 * k[i];
			ph_temp = ph_temp + ph[i];
		}

		angle_cal = -ph_temp;
	}

	if (sign == 1)
	{
		angle_cal = -angle_cal;
	}

	else
	{
		angle_cal = angle_cal;
	}

	return 180 * angle_cal / PI;

}


int main()
{
	int* a1 = new int[10001] {};
	int* b1 = new int[10001] {};

	double* x1 = new double[10001] {};
	double* y1 = new double[10001] {};

	srand(time(0));

	for (int i = 0; i < 10000; i++)   // Arrays of 10,000 elements taken here.
	{
		a1[i] = (rand() % (15707 - -15707)) + -10000; //values starting from 1 and goes upto 100. 
		b1[i] = (rand() % (15707 - -15707)) + -10000; //values starting from 1 and goes upto 100. 

	}

	for (int k = 0; k < 10000; k++)   // Arrays of 10,000 elements taken here.
	{
		x1[k] = a1[k] / 100.;
		y1[k] = b1[k] / 100.;

	}

	for (int n = 0;n < 10000; n++)
	{
		double arctan_calc1 = arctan1(x1[n], y1[n]);
		double arctan_real1 = 180 * atan(y1[n] / x1[n]) / PI;
		double error_abs1 = abs(arctan_real1 - arctan_calc1);

		if (error_abs1 > 0.0000005)

		{
			printf("Error is more than .0000005 \n");
			printf("%f %f   %f    %f  %f\n", x1[n], y1[n], arctan_calc1, arctan_real1, error_abs1);
		}

	}

	int* a2 = new int[10001] {};
	int* b2 = new int[10001] {};

	double* x2 = new double[10001] {};
	double* y2 = new double[10001] {};

	srand(time(0));

	for (int i = 0; i < 10000; i++)   // Arrays of 10,000 elements taken here.
	{
		a2[i] = (rand() % (15707 - -15707)) + -10000; //values starting from 1 and goes upto 100. 
		b2[i] = (rand() % (15707 - -15707)) + -10000; //values starting from 1 and goes upto 100. 

	}

	for (int k = 0; k < 10000; k++)   // Arrays of 10,000 elements taken here.
	{
		x2[k] = a2[k] / 100.;
		y2[k] = b2[k] / 100.;

	}

	for (int n = 0;n < 10000; n++)
	{
		double arctan_calc2 = arctan2(x2[n], y2[n]);
		double arctan_real2 = 180 * atan(y2[n] / x2[n]) / PI;
		double error_abs2 = abs(arctan_real2 - arctan_calc2);

		if (error_abs2 > 0.0000005)

		{
			printf("Error is more than .0000005 \n");
			printf("%f %f   %f    %f  %f\n", x2[n], y2[n], arctan_calc2, arctan_real2, error_abs2);
		}

	}
	int* a3 = new int[10001] {};
	int* b3 = new int[10001] {};

	double* x3 = new double[10001] {};
	double* y3 = new double[10001] {};

	srand(time(0));

	for (int i = 0; i < 10000; i++)   // Arrays of 10,000 elements taken here.
	{
		a3[i] = (rand() % (15707 - -15707)) + -10000; //values starting from 1 and goes upto 100. 
		b3[i] = (rand() % (15707 - -15707)) + -10000; //values starting from 1 and goes upto 100. 

	}

	for (int k = 0; k < 10000; k++)   // Arrays of 10,000 elements taken here.
	{
		x3[k] = a3[k] / 100.;
		y3[k] = b3[k] / 100.;

	}

	for (int n = 0;n < 10000; n++)
	{
		double arctan_calc3 = arctan3(x3[n], y3[n]);
		double arctan_real3 = 180 * atan(y3[n] / x3[n]) / PI;
		double error_abs3 = abs(arctan_real3 - arctan_calc3);

		if (error_abs3 > 0.0000005)

		{
			printf("Error is more than .0000005 \n");
			printf("%f %f   %f    %f  %f\n", x3[n], y3[n], arctan_calc3, arctan_real3, error_abs3);
		}

	}
	int* a4 = new int[10001] {};
	int* b4 = new int[10001] {};

	double* x4 = new double[10001] {};
	double* y4 = new double[10001] {};

	srand(time(0));

	for (int i = 0; i < 10000; i++)   // Arrays of 10,000 elements taken here.
	{
		a4[i] = (rand() % (15707 - -15707)) + -10000; //values starting from 1 and goes upto 100. 
		b4[i] = (rand() % (15707 - -15707)) + -10000; //values starting from 1 and goes upto 100. 

	}

	for (int k = 0; k < 10000; k++)   // Arrays of 10,000 elements taken here.
	{
		x4[k] = a4[k] / 100.;
		y4[k] = b4[k] / 100.;

	}

	for (int n = 0;n < 10000; n++)
	{
		double arctan_calc4 = arctan4(x4[n], y4[n]);
		double arctan_real4 = 180 * atan(y4[n] / x4[n]) / PI;
		double error_abs4 = abs(arctan_real4 - arctan_calc4);

		if (error_abs4 > 0.0000005)

		{
			printf("Error is more than .0000005 \n");
			printf("%f %f   %f    %f  %f\n", x4[n], y4[n], arctan_calc4, arctan_real4, error_abs4);
		}

	}
	int* a5 = new int[10001] {};
	int* b5 = new int[10001] {};

	double* x5 = new double[10001] {};
	double* y5 = new double[10001] {};

	srand(time(0));

	for (int i = 0; i < 10000; i++)   // Arrays of 10,000 elements taken here.
	{
		a5[i] = (rand() % (15707 - -15707)) + -10000; //values starting from 1 and goes upto 100. 
		b5[i] = (rand() % (15707 - -15707)) + -10000; //values starting from 1 and goes upto 100. 

	}

	for (int k = 0; k < 10000; k++)   // Arrays of 10,000 elements taken here.
	{
		x5[k] = a5[k] / 100.;
		y5[k] = b5[k] / 100.;

	}

	for (int n = 0;n < 10000; n++)
	{
		double arctan_calc5 = arctan5(x5[n], y5[n]);
		double arctan_real5 = 180 * atan(y5[n] / x5[n]) / PI;
		double error_abs5 = abs(arctan_real5 - arctan_calc5);

		if (error_abs5 > 0.0000005)

		{
			printf("Error is more than .0000005 \n");
			printf("%f %f   %f    %f  %f\n", x5[n], y5[n], arctan_calc5, arctan_real5, error_abs5);
		}

	}

	printf("\n Error is less than 5e-7 \n");

}